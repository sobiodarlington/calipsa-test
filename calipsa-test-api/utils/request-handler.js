'use strict';

/* eslint-disable no-undef */
const express = require('express');
const http = require('http').Server(express());
const io = require('socket.io')(http);
const { validationResult, matchedData } = require('express-validator');
const Sequelize = require('sequelize');
const BaseError = require('../exceptions/base-error');

http.listen(9090, '0.0.0.0');
io.on('connection', () => {
    _console.info('A user is connected');
});

function handle(controller, callback) {
    return function responseHandlerFunction(req, res) {
        const errors = validationResult(req);

        if (!errors.isEmpty()) {
            return sendResponse(res, {
                statusCode: 400,
                responseCode: 400,
                responseText: parseExpressValidationErrors(errors.array()),
                error: errors.mapped(),
            });
        }

        const body = matchedData(req, {
            includeOptionals: false,
            locations: ['body'],
        });

        const params = matchedData(req, {
            includeOptionals: false,
            locations: ['params'],
        });

        const query = matchedData(req, {
            includeOptionals: false,
            locations: ['query'],
        });

        const httpRequest = {
            io,
            body,
            query,
            params,
            method: req.method,
            path: req.path,
            headers: req.headers,
            user: req.user,
            txnData: req.txnData,
            logData: req.logData,
        };

        return controller(httpRequest)
            .then((httpRes) => {
                if (httpRes.headers) {
                    res.set(httpRes.headers);
                } else {
                    res.set({ 'Content-Type': 'application/json' });
                }

                sendResponse(res, httpRes);

                if (!httpRes.error && typeof callback === 'function') {
                    callback(httpRes, httpRequest);
                }

                if (httpRes.error) {
                    logErrors(httpRes.error);
                }
            })
            .catch((e) => {
                return handleAppExceptions(e, res);
            });
    };
}

function sendResponse(res, httpRes) {
    const responseData = {
        responseCode:
            httpRes.responseCode !== undefined ? httpRes.responseCode : 1,
        responseText: httpRes.responseText || 'ok',
    };

    if (httpRes.error) {
        responseData.responseCode = 0;
        responseData.error = {
            message: httpRes.error.message,
            code: httpRes.error.code,
        };
    }

    if (httpRes.data) {
        responseData.data = httpRes.data || null;
    }

    res.status(httpRes.statusCode).json(responseData);
}

function handleAppExceptions(e, res) {
    let valMsg = null;
    let DBValErrors = null;
    const isAppError = e instanceof BaseError;
    const message = isAppError ? e.message : null;

    if (e.origin && Array.isArray(e.origin)) {
        DBValErrors = parseSeqelizeValidationErrors(e.origin);
        valMsg = parseExpressValidationErrors(DBValErrors);
    }

    sendResponse(res, {
        statusCode: valMsg ? 400 : e.statusCode || 500,
        responseCode: 0,
        responseText:
            valMsg
            || message
            || 'There’s been a glitch… We’re not quite sure what went wrong.',
        error: e,
    });

    logErrors(e);
}

/**
 * @description Non blocking error logging using the Event loop
 */
function logErrors(error) {
    setTimeout(() => {
        if (Array.isArray(error)) {
            error.forEach(e => logErrors(e));
        }

        _console.log(error);
    });
}

function parseSeqelizeValidationErrors(errors) {
    const tmpArr = [];

    errors.forEach((error) => {
        if (error instanceof Sequelize.ValidationErrorItem) {
            tmpArr.push({
                msg: error.message,
            });
        }
    });

    return tmpArr;
}

/**
 * @description transforms errors generated by express validator
 *  to a single message string with each message separated by '|'
 *
 * @param errors {Array}
 * @returns {string} 'Error 1 | Error 2 | Error 3'
 */
function parseExpressValidationErrors(errors) {
    let msgs = '';

    if (!Array.isArray(errors) && typeof errors === 'string') return errors;

    if (!errors.length) return '';

    errors.forEach((item) => {
        msgs += `${item.msg || ''} | `;
    });

    return msgs.replace(/\s\|\s$/, '');
}

module.exports = {
    sendResponse,
    handle,
    handleAppExceptions,
    logErrors,
};
